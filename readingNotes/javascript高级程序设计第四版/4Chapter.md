# 第四章

## 本章内容

- 通过变量使用原始值与引用值
- 理解执行上下文
- 理解垃圾回收

## 可能遇到的面试题

1、原始值和引用值的区别
2、参数传值是什么方式？
3、了解过执行上下文吗？
4、了解过作用域链吗？
5、了解过作用域链增强吗？
6、如何判断对象类型？（这里提到有一种）
7、谈谈JavaScript垃圾回收机制
8、了解内存泄漏吗？如何规避？
9、性能优化？（这章里关于：隐藏类，常量池和静态分配）

## 知识点

1. 原始值（简单数据类型）： 按值访问，操作的是实际值；

   引用值（对象）：按引用访问，操作的是对该对象的引用，而非实际的对象本身，引用值的复制和传递实际上是一个指向该对象的指针

2. 类型判断：

   - typeof ：是判断一个变量是否为字符串、数值、布尔值或 undefined 的最好方式
   - instanceof: 判断Array，RegExp

3. 执行上下文与作用域：

   - 每个上下文都有一个关联的变量对象（vo,variable object）

   - 全局上下文是最外层的上下文

   - 每个函数调用都有自己的上下文。

   - 上下文中的代码在执行的时候，会创建**变量对象**的一个**作用域链（scope chain）**。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。

   - 每个上下文都可以到上一级上下文中去搜索变量和函数，但任何上下文都不能到下一级上下文中去搜索。

4. ECMAScript程序的执行流：当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。

5. 活动对象（activation object）：最初只有一个定义变量：arguments。（全局上下文中没有这个变量。）如果上下文是函数，则其活动对象（activation object）用作变量对象。

6. 全局上下文的变量对象始终是作用域链的最后一个变量对象。

7. 代码执行时的标识符解析： 通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。）

8. 垃圾回收基本思路：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。

9. JavaScript 垃圾回收策略：

   1. **标记清理**：垃圾回收程序运行的时候，会**标记内存中存储的所有变量**（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量**引用的变量的标记去掉**。在此之后**被加上标记的变量就是待删除的了**，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。
   2. **引用计数**：对每个值都**记录它被引用的次数**。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。
      - 存在循环引用的问题：对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。
      - 为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。
   3. 运行垃圾回收的时机：
   4. 现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。如：在一次完整的垃圾回收之后，V8 的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。

10. 内存优化：优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 null，从而释放其引用，即**解除引用**。

    - 通过 **const** 和 **let** 声明提升性能，块作用域比函数作用域更早终止

    - V8 在将解释后的 JavaScript代码编译为实际的机器码时会利用“隐藏类”。

      - 把不想要的属性设置为 null

      - 是避免 JavaScript 的“先创建再补充”（ready-fire-aim）式的动态属性赋值，并在

        构造函数中一次性声明所有属性

    - 内存泄漏的原因：

      - 意外声明全局变量
      - 使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏

    - 减慢对象更替的速度

      - 对象池：在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。
      - 静态分配：初始化时就创建一个大小够用的数组，从而避免因数组大小变化导致的删除再创建的操作。

## 总结

JavaScript 变量可以保存两种类型的值：原始值和引用值。原始值可能是以下 6 种原始数据类型之一：Undefined、Null、Boolean、Number、String 和 Symbol。原始值和引用值有以下特点。

- 原始值大小固定，因此保存在栈内存上。

- 从一个变量到另一个变量复制原始值会创建该值的第二个副本。

- 引用值是对象，存储在堆内存上。

- 包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。

- 从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。

- typeof 操作符可以确定值的原始类型，而 instanceof 操作符用于确保值的引用类型。

任何变量（不管包含的是原始值还是引用值）都存在于某个执行上下文中（也称为作用域）。这个上下文（作用域）决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结如下。

- 执行上下文分全局上下文、函数上下文和块级上下文。

- 代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。

- 函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。

- 全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。

- 变量的执行上下文用于确定什么时候释放内存。

JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript 的垃圾回收程序可以总结如下。

- 离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。

- 主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。

- 引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对象（如 DOM 元素）。

- 引用计数在代码中存在循环引用时会出现问题。

- 解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对象、全局对象的属性和循环引用都应该在不需要时解除引用。

